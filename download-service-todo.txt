CODE REVIEW
------------

- The code is already very readable and well structured :-)

COMMENTS
--------
Please once the are resolve, mark them somehow as resolved, so we can keep track of everything ;-)


- missing environment variables
- remove: https://github.com/lblod/loket-download-url-service/blob/master/app.js#L6 or replace with some decent hello message: https://github.com/lblod/deliver-bbcdr-rapporten-service/blob/master/app.js#L10
- missing: cronjobs
- why duplication?: https://github.com/lblod/loket-download-url-service/blob/master/app.js#L20
- [OPTIONAL]: replace "cached" with uri a little cleaner. But really not mandatarory
- doublecheck whether this filter really really works:  https://github.com/lblod/loket-download-url-service/blob/master/app.js#L28
- not entirely sure, but check wether the result of .bindings will ALWAYS be an array, else append it wiht a '|| []'
  (or you can do this by default): https://github.com/lblod/loket-download-url-service/blob/master/app.js#L32
- the whole procedure: https://github.com/lblod/loket-download-url-service/blob/master/app.js#L11 should be separate function. Can be called by both cronjob and 'api call /checkurls'
- we need an intermediate status 'downloading'.
  Why? because suppose download takes long time and cronjob starts again. This might lead to duplicate files. We don't want this. See also:
  https://github.com/lblod/deliver-bbcdr-rapporten-service/blob/master/app.js#L22
- Somehow, in our other services with similar flow, we don't wait for all promises to resolve.
  I am unsure why though, but I don't see a danger here to not wait for all promises to resolve,
  So I would skip the waiting here too: https://github.com/lblod/loket-download-url-service/blob/master/app.js#L43
- perhaps send a "job started message" instead: https://github.com/lblod/loket-download-url-service/blob/master/app.js#L44
- like other services put this at the end of your file: https://github.com/lblod/loket-download-url-service/blob/master/app.js#L47
- any reason why you use reslove instead of reject (which throws error)
- (for reasons which will be clear later)
  let localAddress = `${FILE_STORAGE}/${uuid()}.${mime.extension(mimeType)}`; -> store the filename in a separate key in you hash
  So do
  let physicalFileName =${uuid()}.${mime.extension(mimeType)};
  let localAddress = `${FILE_STORAGE}/${physicalFileName}`;
  //and later in this function return
  return { ...., physicalFileName }


- we still miss error handling here: https://github.com/lblod/loket-download-url-service/blob/master/app.js#L37 (try/catch? and update status accordingly)
- we need clean up logic here. If something fails during writing of the file, and the file exists (albeit partially) we need to clean it up.
  Use:  fs.unlinkSync(path); //after first having checked the file exists.
  https://github.com/lblod/loket-download-url-service/blob/master/app.js#L109
  
- line https://github.com/lblod/loket-download-url-service/blob/master/app.js#L150
  misses dbpedia prefix



CREATION OF THE FILE DATA (function associateCachedFile)
-------------------------------------------------------
  GENERAL
  -------
  So, once you downloaded the file, we want it to be accessible to the following service:  https://github.com/mu-semtech/file-service
  Why? Because, this easily integrates with the rest of the stack, and the downloaded file will then appear in digitaal-loket as a file to download.
  But this specific service expects some specific resources in the database to work on (see also DOC on github, but first keep reading :-))
  So 2 rerouces are needed:
  The file service represents an uploaded file as 2 resources in the triplestore: a resource reflecting the (virtual) downloaded file and another resource reflecting the resulting file stored on disk.

  What you have been creating so far, is the (virtual) downloaded file. Let's first dig in this one

  VIRTUAL DOWNLOADED FILE
  ------------------------

  EXAMPLE OF FILE DATA FIELDS IN THE DB
  (you can check  it yourself by uploading a file through the forms loket)
  SELECT * {
    GRAPH ?g {
     ?s a nfo:FileDataObject.
     ?s ?p ?o.
     ?physicalFile ?physicalFileP ?s.
     ?physicalFile ?physicalFileP ?physicalFileO.
   }
  }

  Let's break the query down:

        PREFIX ext: <http://mu.semte.ch/vocabularies/ext/>
        PREFIX nfo: <http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#>
        PREFIX nie: <http://www.semanticdesktop.org/ontologies/2007/01/19/nie#>
        PREFIX dct: <http://purl.org/dc/terms/>
        INSERT {
          GRAPH ?g {
          #####
          # should be written to GRAPH <http://mu.semte.ch/graphs/public> {
          #
          ######


            # make a file resource
            ?file a
                nfo:FileDataObject;
                nfo:fileName "${uid}";


                #################################################
                #nfo:fileName needs to be the 'name readable' for user: ' e.g. burgemeesters2019_20190103_bis.xlsx -> let's call this the logical name
                # e.g. from http://foo.com/baz/bar
                # I would suggest the pattern: CACHED_FILE_FOO_COM_BAZ_BAR_UUID.extension_from_mimetype
                # I would use a libray to sanitize file name: https://www.npmjs.com/package/sanitize-filename
                # and also check this https://stackoverflow.com/a/27006391/1092608 (but non mandatory, refer to the library first)
                # Filenames are a tricky thing, so let's be quite restrictive on it
                # Furthemore I would abstract the creation of logical or 'user friendly' name to a function. We can later develop a more smart heuristic to make the filenames
                # even more user friendly, but this would be a matter of updating your function
                ######################################################################

                dct:format "${downloadResult.result.headers['content-type']}";
                nfo:fileSize "${downloadResult.result.headers['content-length']}";

                 ##################################################################
                 # nfo:fileSize: better to use
                 #  const stats = fs.statSync(pathOfYourFIle);
                 #  const fileSize = stats.size;
                 #  and inject this in your query
                 ##################################################################

                dbpedia:fileExtension "${downloadResult.result.headers['content-type'].split('/')[1]}";
                
                 ##################################################################
                 # nfo:fileExtensions: use the one extracted from .${mime.extension(mimeType)}`;
                 ##################################################################

                nfo:fileCreated "${downloadResult.result.headers['date']}";

                 ##################################################################
                 # nfo:fileCreated: use the exact time you created the file when downloading it.
                 ##################################################################

                <http://mu.semte.ch/vocabularies/core/uuid> "${uid}".
            # associate it to our original FileAddress object
            ########################################
            # should be written to the graph you found it
            # and also replace nie:dataSource with e.g. ext:chachedFileResource
            ##############################################
            GRAPH ?g {
            <${downloadResult.resource.uri.value}> nie:dataSource ?file.
            }
          }
        }
        WHERE {
          GRAPH ?g {
            ?s a ext:FileAddress
          }
          BIND(IRI("${fileResourcePath}/${uid}") as ?file).
          #####
          # I would make an uri wich somehow easily gives an indication where it comes from
          # e.g.const fileResourcePath = "http://data.lblod.info/loket-download-url-service/virtual/${uuid}";
          # Furthermore, you can create the URI with javascript and inject in the string of your query. You will be able so re-use it later more easily
          ###


        }
      `);


  PHYSICAL FILE
  -------------
  This is a very similar query, and you can append it (by separating it with ';') to the previous query. It is also an insert query
    ${sparqlEscapeUri(share://${physicalFileName})} a nfo:FileDataObject;
      nie:dataSource ${sparqlEscapeUri('THE_URI_YOU_GENERATED_FOR_PREVIOUS_INSER')};
      nfo:fileName ${sparqlEscapeString(`${physicalFileName}`)};
      mu:uuid ${sparqlEscapeString(`A_NEW_UUID`)};
      dcterms:format ${sparqlEscapeString(`SAME_AS_IN_PREVIOUS_QUERY`)};
      nfo:fileSize ${sparqlEscapeString(`SAME_AS_IN_PREVIOUS_QUERY`)};
      dbo:fileExtension ${sparqlEscapeString(`SAME_AS_IN_PREVIOUS_QUERY`)};
      dcterms:created ${sparqlEscapeString(`SAME_AS_IN_PREVIOUS_QUERY`)}.




  GENERAL COMMENT FOR INSERTING
  -----------------------------
  use sparqlEscapeString() like e.g. https://github.com/lblod/deliver-bbcdr-rapporten-service/blob/master/queries.js#L25


FUNCTION  updateStatus
---------------------
  GENERAL
  ------
  - I would split the function in 2 parts.
    - A part which is concerned of creating the query string and the execution of the query itself.
    - A part on what status we want to give it.
      - There will be much logic residing here so better to keep it atomic or 'boxed'
     - I think this would total to:
         updateStatus(newStatus)
         getStatusAfterDownloadJob(downloadResult) //or similar

   ABOUT getStatusAfterDownloadJob
   -------------------------------
   I am currently thinkging about the following statuses

   if 200<= code < 300
      'cached'
   else if attempts < maxNumberOfAttempts
      'pending'
      'update timestamp last attempt' -> //no double downloads
   else
      'failed'


NEW FEATURES
-------------
- I don't know what happens if you have a 30X redirect. Some clients follow the redirect others just errors. We have to check (be in in the doc, or by hand)
  We have to make sure we have the redirect. https://github.com/lblod/loket-download-url-service/blob/master/app.js#L97
- Quite often, the mime type is not provided. https://github.com/lblod/loket-download-url-service/blob/master/app.js#L103 We have libraries to tackle these.
 But as first mvp, let's do .txt as a default
 - Actually we need only to download the files, associated with an inzending for toezicht on status 'VERSTUURD'
 - SEAS should be used
- [NEXT ITERATION] in the url box in frontend, display a link to the cached file so it can be downloaded
- [NEXT ITERATION] If we have HTML, download images
- [NEXT ITERATION] handle funky ssl issues
- [NEXT ITERATION] handle sinlge page app
